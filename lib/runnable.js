/**
 * Module dependencies.
 */

var EventEmitter = require('events').EventEmitter;
var util = require('util');

var debug = require('debug')('violence:runnable');

var Pending = require('./pending');
var utils = require('./utils');

/**
 * Expose `Runnable`.
 */

module.exports = Runnable;

/**
 * Initialize a new `Runnable` with the given `title` and callback `fn`.
 *
 * @api private
 * @param {string} title
 * @param {Function} fn
 */
function Runnable(title, fn) {
    this.title = title;
    this.fn = fn;
    this._trace = new Error('done() called multiple times');
}

/**
 * Inherit from `EventEmitter.prototype`.
 */

util.inherits(Runnable, EventEmitter);

var ptp = Runnable.prototype;

/**
 * Halt and mark as pending.
 *
 * @api private
 */
ptp.skip = function() {
    throw new Pending();
};

/**
 * Return the full title generated by recursively concatenating the parent's
 * full title.
 *
 * @api public
 * @return {string}
 */
ptp.fullTitle = function() {
    return this.parent.fullTitle() + ' ' + this.title;
};

/**
 * Clear the timeout.
 *
 * @api private
 */
ptp.clearTimeout = function() {
    clearTimeout(this.timer);
};

/**
 * Inspect the runnable void of private properties.
 *
 * @api private
 * @return {string}
 */
ptp.inspect = function() {
    return JSON.stringify(this, function(key, val) {
        if (key[0] === '_') {
            return;
        }
        if (key === 'parent') {
            return '#<Scope>';
        }
        if (key === 'ctx') {
            return '#<Context>';
        }
        return val;
    }, 2);
};

/**
 * Whitelist a list of globals for this test run.
 *
 * @api private
 * @param {string[]} globals
 */
ptp.globals = function(globals) {
    this._allowedGlobals = globals;
};

/**
 * Run the test and invoke `fn(err)`.
 *
 * @api private
 * @param {Function} fn
 */
ptp.run = function(fn) {
    var self = this;
    var start = new Date();
    var ctx = this.ctx;
    var finished;
    var emitted;

    // Sometimes the ctx exists, but it is not runnable
    if (ctx && ctx.runnable) {
        ctx.runnable(this);
    }

    // called multiple times
    function multiple(err) {
        if (emitted) {
            return;
        }
        emitted = true;
        self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));
    }

    // finished
    function done(err) {
        if (finished) {
            return multiple(err || self._trace);
        }

        finished = true;
        fn(err);
    }

    // sync or promise-returning
    try {
        if (this.pending) {
            done();
        } else {
            callFn(this.fn);
        }
    } catch (err) {
        done(utils.getError(err));
    }

    function callFn(fn) {
        var result = fn.call(ctx);
        if (result && typeof result.then === 'function') {
            self.resetTimeout();
            result
                .then(function() {
                    done();
                },
                function(reason) {
                    done(reason || new Error('Promise rejected with no or falsy reason'));
                });
        } else {
            done();
        }
    }
};
